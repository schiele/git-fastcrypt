#!/usr/bin/env python3

import pygit2
import hashlib
import subprocess
import os
import sys
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

def progressbar(progress, total, length=50):
    if not total:
        sys.stdout.write('\r' + ' ' * (length + 7) + '\r')
        sys.stdout.flush()
        return
    percent = progress / total
    bar = 'â–ˆ' * int(percent * length) + '-' * (length - int(percent * length))
    sys.stdout.write(f'\r|{bar}| {percent:.0%}')
    sys.stdout.flush()

def encryptdata(data: bytes, key: bytes) -> (bytes, bytes):
    cipher = Cipher(algorithms.AES(key[0:32]), modes.CBC(key[32:48]), backend=default_backend())
    encryptor = cipher.encryptor()
    padder = padding.PKCS7(algorithms.AES.block_size).padder()
    padded_data = padder.update(data) + padder.finalize()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return ciphertext

def decryptdata(ciphertext: bytes, key: bytes) -> bytes:
    cipher = Cipher(algorithms.AES(key[0:32]), modes.CBC(key[32:48]), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_padded_data = decryptor.update(ciphertext) + decryptor.finalize()
    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
    decrypted_data = unpadder.update(decrypted_padded_data) + unpadder.finalize()
    return decrypted_data

def calcraw(clear, repo):
    data = clear.id.raw + [b'1', b'c', b't', b'b', b'T'][clear.type] + clear.read_raw()
    return repo.__contains__(hashlib.sha1(b'blob ' + str(len(data)).encode() + b'\0' + data).hexdigest())

def cryptraw(clear, collector, repo, cryptcache):
    cryptid = repo.create_blob(encryptdata(clear.id.raw + [b'?', b'c', b't', b'b', b'T'][clear.type] + clear.read_raw(), key))
    collector.insert(str(len(collector)), cryptid, pygit2.GIT_FILEMODE_BLOB)
    cryptcache[clear.id] = True

def encryptblob(blob, collector, repo, cryptcache):
    if blob.id in cryptcache:
        return
    cryptraw(blob, collector, repo, cryptcache)

def encrypttree(tree, collector, repo, cryptcache):
    if tree.id in cryptcache:
        return
    for obj in tree:
        if obj.type == pygit2.enums.ObjectType.TREE:
            encrypttree(obj, collector, repo, cryptcache)
        elif obj.type == pygit2.enums.ObjectType.BLOB:
            encryptblob(obj, collector, repo, cryptcache)
    cryptraw(tree, collector, repo, cryptcache)

def encryptcommit(commit, repo, processed, cryptcache):
    collector = repo.TreeBuilder()
    encrypttree(commit.tree, collector, repo, cryptcache)
    cryptraw(commit, collector, repo, cryptcache)
    colid = collector.write()
    cryptparents = list(map(lambda c: processed[c], commit.parent_ids))
    nobody = pygit2.Signature('nobody', 'nobody@nowhere.org', time=0, offset=0)
    processed[commit.id.__str__()] = repo.create_commit(None, nobody, nobody, 'secret', colid, cryptparents).__str__()

def encrypttag(tag, repo, processed, cryptcache):
    collector = repo.TreeBuilder()
    cryptraw(tag, collector, repo, cryptcache)
    colid = collector.write()
    nobody = pygit2.Signature('nobody', 'nobody@nowhere.org', time=0, offset=0)
    processed[tag.id.__str__()] = repo.create_commit(None, nobody, nobody, 'secret', colid, [processed[tag.target]]).__str__()

def iscomplete(obj, processed):
    if obj.type == pygit2.enums.ObjectType.COMMIT:
        for p in obj.parents:
            if p.id not in processed:
                return False
        return True
    elif obj.type == pygit2.enums.ObjectType.TAG:
        return obj.target in processed
    else:
        raise

def register(obj, child, found, pending, ready, processed, children):
    if obj.id not in children:
        children[obj.id] = []
    if child:
        children[obj.id].append(child)
    if all(obj.id not in d for d in (found, pending, ready, processed)):
        found[obj.id] = obj

def encryptref(refs, sourcerepo, targetrepo):
    found = {}
    pending = {}
    ready = {}
    processed = readmap(targetrepo)
    children = {}
    cryptcache = {}

    inits = list(map(sourcerepo.revparse_single, refs))
    for init in inits:
        register(init, None, found, pending, ready, processed, children)
    while(found):
        id, obj = found.popitem()
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            for p in obj.parents:
                register(p, obj, found, pending, ready, processed, children)
        elif obj.type == pygit2.enums.ObjectType.TAG:
            register(obj.get_object(), obj, found, pending, ready, processed, children)
        else:
            raise
        if iscomplete(obj, processed):
            ready[id] = obj
        else:
            pending[id] = obj
    total = len(pending) + len(ready)
    totalignore = len(processed)
    while(ready):
        id, obj = ready.popitem()
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            encryptcommit(obj, targetrepo, processed, cryptcache)
        elif obj.type == pygit2.enums.ObjectType.TAG:
            encrypttag(obj, targetrepo, processed, cryptcache)
        else:
            raise ValueError('Unsupported object type')
        for c in children[id]:
            if c.id not in pending:
                continue
            if iscomplete(c, processed):
                ready[c.id] = pending.pop(c.id)
        progressbar(len(processed) - totalignore, total)
    progressbar(0, 0)
    if len(found) + len(pending) + len(ready) > 0:
        print(f'found: {found}')
        print(f'pending: {pending}')
        print(f'ready: {ready}')
        raise
    writemap(processed, targetrepo)
    return list(map(lambda i: processed[i.id], inits))

def decryptref(cryptrefs, sourcerepo, targetrepo, targetname):
    found = {}
    cryptmap = {}
    inits = list(map(sourcerepo.revparse_single, cryptrefs))
    for init in inits:
        found[init.id] = init
    while(found):
        id, cryptdata = found.popitem()
        for obj in cryptdata.tree:
            raw = decryptdata(obj.read_raw(), key)
            if raw[20] == b'b'[0]:
                targetrepo.create_blob(raw[21:])
                #subprocess.check_output(['git', '-C', targetname, 'hash-object', '-t', 'blob', '-w', '--stdin'], input=raw[21:]).decode('utf-8').strip()
            elif raw[20] == b't'[0]:
                subprocess.check_output(['git', '-C', targetname, 'hash-object', '-t', 'tree', '-w', '--stdin'], input=raw[21:]).decode('utf-8').strip()
            elif raw[20] == b'c'[0]:
                commit = subprocess.check_output(['git', '-C', targetname, 'hash-object', '-t', 'commit', '-w', '--stdin'], input=raw[21:]).decode('utf-8').strip()
            elif raw[20] == b'T'[0]:
                commit = subprocess.check_output(['git', '-C', targetname, 'hash-object', '-t', 'tag', '-w', '--stdin'], input=raw[21:]).decode('utf-8').strip()
            else:
                print(raw[20:21])
                raise
        cryptmap[id] = commit
        obj = targetrepo.get(commit)
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            missing = False
            for parent in obj.parent_ids:
                if not targetrepo.__contains__(parent):
                    missing = True
                    break
            if missing:
                for parent in cryptdata.parents:
                    found[parent.id] = parent
        elif obj.type == pygit2.enums.ObjectType.TAG:
            if not targetrepo.__contains__(obj.target):
                found[cryptdata.parent_ids[0]] = cryptdata.parents[0]
    return list(map(lambda i: cryptmap[i.id], inits))

def makekey(repo):
    try:
        cryptedkey = repo.get(repo.revparse_single('refs/tags/key').id).read_raw()
        return subprocess.check_output(['gpg', '-q', '-d'], input=cryptedkey)
    except KeyError:
        pass
    key = os.urandom(48)
    cryptedkey = subprocess.check_output(['gpg', '-q', '-e', '-r', '5A8A11E44AD2A1623B84E5AFC5C0C5C7218D18D7', '-r', 'F2AE0B6CB4089F15A217F12D121F59FB963341A4'], input=key)
    keyfile = repo.create_blob(cryptedkey)
    repo.create_reference('refs/tags/key', keyfile, force=True)
    return key

def readmap(repo):
    processed = {}
    try:
        rawdata = decryptdata(repo.get(repo.revparse_single('refs/tags/map').id).read_raw(), key)
        for i in range(0, len(rawdata), 40):
            crypt = rawdata[i+20:i+40].hex()
            if repo.__contains__(crypt):
                processed[rawdata[i:i+20].hex()] = crypt
    except KeyError:
        pass
    return processed

def writemap(processed, repo):
    rawdata = b''
    for a, b in processed.items():
        rawdata += bytes.fromhex(a) + bytes.fromhex(b)
    mapfile = repo.create_blob(encryptdata(rawdata, key))
    repo.create_reference('refs/tags/map', mapfile, force=True)

operation = sys.argv[1]
source = sys.argv[2]
target = sys.argv[3]
whats = []
wheres = []
for what in sys.argv[4:]:
    elements = what.split(':', 1)
    whats.append(elements[0])
    wheres.append(elements[len(elements)-1])

sourcerepo = pygit2.Repository(source)
targetrepo = pygit2.Repository(target)

if operation[0:1] == 'e':
    key = makekey(targetrepo)
    secret = encryptref(whats, sourcerepo, targetrepo)
    for i in range(0, len(wheres)):
        targetrepo.create_reference(wheres[i], secret[i], force=True)
elif operation[0:1] == 'd':
    key = makekey(sourcerepo)
    public = decryptref(whats, sourcerepo, targetrepo, target)
    for i in range(0, len(wheres)):
        targetrepo.create_reference(wheres[i], public[i], force=True)
else:
    raise
