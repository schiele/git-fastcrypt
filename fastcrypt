#!/usr/bin/env python3
'''
Encrypt git branches
'''

import subprocess
import os
import sys
import re
import hashlib
import pygit2
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

FORMAT = b'\x00\x00\x00\x00'


def progressbar(progress, total, length=50):
    'print a progress bar'
    if not total:
        sys.stdout.write('\r' + ' ' * (length + 7) + '\r')
        sys.stdout.flush()
        return
    percent = progress / total
    pbar = 'â–ˆ' * int(percent * length) + '-' * (length - int(percent * length))
    sys.stdout.write(f'\r|{pbar}| {percent:.0%}')
    sys.stdout.flush()


def cipher(key):
    'return cipher to be used'
    return Cipher(algorithms.AES(key[0:32]), modes.CBC(key[32:48]),
                  backend=default_backend())


def pad():
    'return patting to be used'
    return padding.PKCS7(algorithms.AES.block_size)


def encryptdata(data: bytes, key: bytes) -> (bytes, bytes):
    'encrypt raw data'
    e = cipher(key).encryptor()
    p = pad().padder()
    return e.update(p.update(data) + p.finalize()) + e.finalize()


def decryptdata(ciphertext: bytes, key: bytes) -> bytes:
    'decrypt raw data'
    d = cipher(key).decryptor()
    u = pad().unpadder()
    return u.update(d.update(ciphertext) + d.finalize()) + u.finalize()


def cryptraw(clear, key, collector, repo, cryptcache):
    'encrypt a raw object'
    cryptid = repo.create_blob(encryptdata(
        clear.id.raw + [b'?', b'c', b't', b'b', b'T'][clear.type] +
        clear.read_raw(), key))
    collector.insert(str(len(collector)), cryptid, pygit2.enums.FileMode.BLOB)
    cryptcache[clear.id] = True


def encryptblob(blob, key, collector, repo, cryptcache):
    'encrypt a blob'
    if blob.id in cryptcache:
        return
    cryptraw(blob, key, collector, repo, cryptcache)


def encrypttree(tree, key, collector, repo, cryptcache):
    'encrypt a tree'
    if tree.id in cryptcache:
        return
    for obj in tree:
        if obj.type == pygit2.enums.ObjectType.TREE:
            encrypttree(obj, key, collector, repo, cryptcache)
        elif obj.type == pygit2.enums.ObjectType.BLOB:
            encryptblob(obj, key, collector, repo, cryptcache)
    cryptraw(tree, key, collector, repo, cryptcache)


def secretcommit(tree, parents, repo, key):
    'create secret commit wrapper'
    data = key[48:].decode('utf-8').split('\x00', 5)
    who = pygit2.repository.Signature(data[0], data[1],
                                      time=int(data[2]), offset=int(data[3]))
    return str(repo.create_commit(None, who, who,
                                  data[4], tree, parents))


def encryptcommit(commit, key, repo, processed, cryptcache):
    'encrypt a commit'
    collector = repo.TreeBuilder()
    encrypttree(commit.tree, key, collector, repo, cryptcache)
    cryptraw(commit, key, collector, repo, cryptcache)
    colid = collector.write()
    cryptparents = list(map(lambda c: processed[c], commit.parent_ids))
    processed[str(commit.id)] = secretcommit(colid, cryptparents, repo, key)


def encrypttag(tag, key, repo, processed, cryptcache):
    'encrypt a tag'
    collector = repo.TreeBuilder()
    cryptraw(tag, key, collector, repo, cryptcache)
    colid = collector.write()
    processed[str(tag.id)] = secretcommit(
        colid, [processed[tag.target]], repo, key)


def iscomplete(obj, processed):
    'check if processing is complete'
    if obj.type == pygit2.enums.ObjectType.COMMIT:
        for p in obj.parents:
            if p.id not in processed:
                return False
        return True
    if obj.type == pygit2.enums.ObjectType.TAG:
        return obj.target in processed
    raise TypeError(f'Unexpected type {obj.type_str} in completeness check')


def register(obj, child, status, children):
    'register new object'
    if obj.id not in children:
        children[obj.id] = []
    if child:
        children[obj.id].append(child)
    if all(obj.id not in d for d in status):
        status[0][obj.id] = obj


def createrefs(repo, refs, inits, cryptmap):
    'create all encrypted or decrypted references'
    for i, ref in enumerate(refs):
        repo.create_reference(ref, cryptmap[inits[i].id], force=True)


def recursivefind(status, children):
    'recursively traverse and find all commits to encrypt'
    while status[0]:
        oid, obj = status[0].popitem()
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            for p in obj.parents:
                register(p, obj, status, children)
        elif obj.type == pygit2.enums.ObjectType.TAG:
            register(obj.get_object(), obj, status, children)
        else:
            raise TypeError(f'Unexpected type {obj.type_str} in git history')
        if iscomplete(obj, status[3]):
            status[2][oid] = obj
        else:
            status[1][oid] = obj


def topologicalencryption(status, children, key, repo):
    'encrypt all objects in topological order'
    cryptcache = {}
    totals = [len(status[1]) + len(status[2]), len(status[3])]
    while status[2]:
        oid, obj = status[2].popitem()
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            encryptcommit(obj, key, repo, status[3], cryptcache)
        elif obj.type == pygit2.enums.ObjectType.TAG:
            encrypttag(obj, key, repo, status[3], cryptcache)
        else:
            raise TypeError(f'Unexpected type {obj.type_str} in git history')
        for c in children[oid]:
            if c.id not in status[1]:
                continue
            if iscomplete(c, status[3]):
                status[2][c.id] = status[1].pop(c.id)
        progressbar(len(status[3]) - totals[1], totals[0])
    progressbar(0, 0)


def splitref(s):
    'split the ref from the suffix'
    match = re.search(r'[~^]', s)
    if match:
        index = match.start()
        return s[:index], s[index:]
    return s, ''


def encryptrefname(ref, key):
    'encrypt a refname'
    sref = splitref(ref)
    rawname = sref[0].encode('utf-8')
    return 'refs/heads/' + encryptdata(
            hashlib.sha1(rawname).digest() + rawname, key).hex() + sref[1]


def decryptrefname(ref, key):
    'decrypt a refname'
    try:
        data = decryptdata(bytes.fromhex(ref.rsplit('/', 1)[-1]), key)
        assert hashlib.sha1(data[20:]).digest() == data[0:20], \
            'corrupted reference name'
        return data[20:].decode('utf-8')
    except ValueError:
        return None


def encryptref(repolocs, refs):
    'encrypt references'
    repos = list(map(pygit2.Repository, repolocs))

    key = getkey(repos[1])
    # [ found, pending, ready, processed ]
    status = [{}, {}, {}, readmap(key, repos[1])]
    children = {}

    if not refs:
        refs = list(map(lambda r: [r, r], filter(
            lambda r: r[-5:] != '/HEAD', repos[0].references)))
    inits = list(map(lambda r: repos[0].revparse_single(r[0]), refs))
    for init in inits:
        register(init, None, status, children)
    recursivefind(status, children)
    topologicalencryption(status, children, key, repos[1])
    if len(status[0]) + len(status[1]) + len(status[2]) > 0:
        print(f'found: {status[0]}')
        print(f'pending: {status[1]}')
        print(f'ready: {status[2]}')
        raise RuntimeError('Not all data got properly processed')
    writemap(status[3], key, repos[1])
    createrefs(repos[1], list(map(lambda r: encryptrefname(r[1], key),
                                  refs)), inits, status[3])


def clihash(tpe, raw, targetname):
    'call external git client for not implemented raw hasing'
    return subprocess.check_output(
        ['git', '-C', targetname, 'hash-object', '-t', tpe, '-w', '--stdin'],
        input=raw[21:]).decode('utf-8').strip()


def decrypttree(tree, key, repo, repoloc):
    'decrypt a tree representing a commit or tag'
    commit = None
    for obj in tree:
        raw = decryptdata(obj.read_raw(), key)
        if raw[20] == b'b'[0]:
            repo.create_blob(raw[21:])
        elif raw[20] == b't'[0]:
            clihash('tree', raw, repoloc)
        elif raw[20] == b'c'[0]:
            commit = clihash('commit', raw, repoloc)
        elif raw[20] == b'T'[0]:
            commit = clihash('tag', raw, repoloc)
        else:
            print(raw[20:21])
            raise TypeError(f'Unexpected git object type {raw[20]}')
    return commit


def decryptref(repolocs, refs):
    'decrypt references'
    repos = list(map(pygit2.Repository, repolocs))

    found = {}
    cryptmap = {}

    key = getkey(repos[0])
    if not refs:
        refs = list(map(lambda r: [r, r], cryptreferences(repos[0], key)))
    inits = list(map(
        lambda r: repos[0].revparse_single(encryptrefname(r[0], key)), refs))
    for init in inits:
        found[init.id] = init
    while found:
        oid, cryptdata = found.popitem()
        commit = decrypttree(cryptdata.tree, key, repos[1], repolocs[1])
        cryptmap[oid] = commit
        obj = repos[1].get(commit)
        if obj.type == pygit2.enums.ObjectType.COMMIT:
            missing = False
            for parent in obj.parent_ids:
                if parent not in repos[1]:
                    missing = True
                    break
            if missing:
                for parent in cryptdata.parents:
                    found[parent.id] = parent
        elif obj.type == pygit2.enums.ObjectType.TAG:
            if obj.target not in repos[1]:
                found[cryptdata.parent_ids[0]] = cryptdata.parents[0]
    createrefs(repos[1], list(map(lambda r: r[1], refs)), inits, cryptmap)


def getkey(repo):
    'retrieve an existing key'
    cryptedkey = repo.get(repo.revparse_single('refs/tags/key').id).read_raw()
    assert cryptedkey[0:4] == FORMAT, \
        f'Crypt format is {cryptedkey[0:4]}, expected {FORMAT}'
    return subprocess.check_output(['gpg', '-q', '-d'], input=cryptedkey[4:])


def readmap(key, repo):
    'read the mapping table'
    processed = {}
    try:
        rawdata = decryptdata(repo.get(
            repo.revparse_single('refs/heads/map').id).read_raw(), key)
        for i in range(0, len(rawdata), 40):
            crypt = rawdata[i+20:i+40].hex()
            if crypt in repo:
                processed[rawdata[i:i+20].hex()] = crypt
    except KeyError:
        pass
    return processed


def writemap(processed, key, repo):
    'write the mapping table'
    rawdata = b''
    for a, b in processed.items():
        rawdata += bytes.fromhex(a) + bytes.fromhex(b)
    mapfile = repo.create_blob(encryptdata(rawdata, key))
    repo.create_reference('refs/heads/map', mapfile, force=True)


def cryptreferences(repo, key):
    'get all crypted references'
    return filter(lambda x: x is not None,
                  map(lambda r: decryptrefname(r, key), repo.references))


def listrefs(reponame):
    'list all cleartext references'
    repo = pygit2.Repository(reponame)
    for r in repo.references:
        print(r)


def listcryptrefs(reponame):
    'list all enctypted references'
    repo = pygit2.Repository(reponame)
    key = getkey(repo)
    for r in cryptreferences(repo, key):
        print(r)


def initcrypt(reponame, keys, data=(
        'nobody', 'nobody@nowhere.org', 0, 0, 'secret')):
    'init crypto repository'
    repo = pygit2.init_repository(reponame, bare=True)
    key = os.urandom(48) + \
        data[0].encode('utf-8') + b'\x00' + \
        data[1].encode('utf-8') + b'\x00' + \
        str(data[2]).encode('utf-8') + b'\x00' + \
        str(data[3]).encode('utf-8') + b'\x00' + \
        data[4].encode('utf-8')
    cryptedkey = subprocess.check_output([
        'gpg', '-q', '-e'] + list(map(lambda k: '-r' + k, keys)), input=key)
    keyfile = repo.create_blob(FORMAT + cryptedkey)
    repo.create_reference('refs/tags/key', keyfile, force=True)
    return key


operation = sys.argv[1]
reponames = sys.argv[2:4]
if len(sys.argv) > 3:
    whats = []
    for what in sys.argv[4:]:
        elements = what.split(':', 1)
        whats.append((elements[0], elements[len(elements)-1]))

if operation[0:1] == 'e':
    encryptref(reponames, whats)
elif operation[0:1] == 'd':
    decryptref(reponames, whats)
elif operation[0:1] == 'l':
    listrefs(reponames[0])
elif operation[0:1] == 'L':
    listcryptrefs(reponames[0])
elif operation[0:1] == 'i':
    if whats:
        initcrypt(reponames[0], reponames[1].split(','), data=sys.argv[4:])
    else:
        initcrypt(reponames[0], reponames[1].split(','))
else:
    raise ValueError(f'Unknown operation {operation}')
